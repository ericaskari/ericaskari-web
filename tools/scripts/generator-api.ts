import workspace from '../../workspace.json';
import baseTsConfig from '../../tsconfig.base.json';
import data from '../../api.json';
import { resolve } from 'path';
import { mkdirSync, writeFileSync } from 'fs';

interface Service {
    name: string;
    endpoints: Endpoint[];
}

interface Endpoint {
    name: string;
    authenticated: boolean;
    customHeaders: boolean;
    type: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    url: string;
    urlProps: { name: string; value: string }[];
    bodyRequest: string;
    paramRequest: string;
    queryParamRequest: string;
    response: string;
}

function toCamelCase(text: string): string {
    return text
        .split(/(?=[A-Z])/)
        .join('-')
        .toLowerCase();
}

function toPascalCase(text: string) {
    return text.charAt(0).toUpperCase() + text.slice(1);
}

const paths = baseTsConfig.compilerOptions.paths;
const tsConfigPaths: Record<keyof typeof paths, keyof typeof paths> = Object.entries(paths)
    .map(([key]) => key)
    .reduce(
        (json, key) => ({
            ...json,
            [key]: key
        }),
        {} as Record<keyof typeof paths, keyof typeof paths>
    );

function serviceNameHelper(service: Service) {
    return {
        serviceName: service.name,
        serviceNameTitleCase: service.name
            .split(' ')
            .map((w) => w[0].toUpperCase() + w.substring(1).toLowerCase())
            .join(' ')
    };
}

function serviceImportHelper(service: Service) {
    return [
        ...new Set(
            [
                // 'UserModel',
                ...service.endpoints.map((x) => x.bodyRequest),
                ...service.endpoints.map((x) => x.paramRequest),
                ...service.endpoints.map((x) => x.queryParamRequest),
                ...service.endpoints.map((x) => x.response)
            ].filter((x) => x !== '')
        )
    ].join(', ');
}

function autoGeneratedMessageHelper() {
    return ['// Auto generated file with generate:api npm command'];
}

function generateFeEndpointFile(service: Service): string {
    const serviceNameCamelCase = toCamelCase(service.name);
    const serviceNameTitleCase = toPascalCase(service.name);
    const serviceImports = serviceImportHelper(service);

    const feImports = [
        `import { HttpClient, HttpParams, HttpHeaders } from '@angular/common/http';`,
        `import { Inject, Injectable } from '@angular/core';`,
        `import { Observable } from 'rxjs';`,
        `import { map } from 'rxjs/operators';`,
        `import { ${serviceImports} } from '${tsConfigPaths['@ericaskari/shared/model']}';`
    ].join('\n');

    const classOpening = [`export class ${serviceNameTitleCase}EndpointService {`];
    const feClassClosing = [`}`];
    const feConstructor = [`    constructor(private httpClient: HttpClient) {}`];

    const feInjectable = [`@Injectable({`, `    providedIn: 'root'`, `})`].join('\n');

    const feMethods = service.endpoints.map((endpoint) => {
        const method = endpoint.type.toLowerCase();
        const hasBody = (method === 'post' || method === 'put') && endpoint.bodyRequest;
        const hasParam = endpoint.urlProps.length > 0 && !!endpoint.paramRequest;
        const hasQueryParam = !!endpoint.queryParamRequest;
        const hasCustomHeader = endpoint.customHeaders;

        const feMethodProps = ([] as string[])
            .concat(hasBody ? [`bodyRequest: ${endpoint.bodyRequest}`] : [])
            .concat(hasParam ? [`paramRequest: ${endpoint.paramRequest}`] : [])
            .concat(hasQueryParam ? [`queryParamRequest: ${endpoint.queryParamRequest}`] : [])
            .concat(hasCustomHeader ? [`headers: HttpHeaders = new HttpHeaders()`] : [])
            .join(', ');

        const url = ([] as string[])
            .concat(['/api'])
            .concat([serviceNameCamelCase])
            .concat(
                endpoint.url
                    ? endpoint.url.split('/').map((urlSection) => {
                          const prop = endpoint.urlProps.find((y) => y.name === urlSection) ?? null;
                          return prop ? `\${${prop.value}}` : urlSection;
                      })
                    : []
            )
            .join('/');

        const feMethodStart: [string] = [`    public ${endpoint.name}(${feMethodProps}): Observable<${endpoint.response}> {`];

        const feMethodData: string[] = ([] as string[])
            .concat(
                hasQueryParam
                    ? ['        const httpParams = new HttpParams({ fromObject: queryParamRequest as unknown as Record<string, string> })']
                    : []
            )
            .concat([
                [
                    ['        '],
                    ['return '],
                    ['this.httpClient.'],
                    [endpoint.type.toLowerCase()],
                    [`<${endpoint.response}>`],
                    [`(`],
                    [
                        ([] as string[])
                            .concat([`\`${url}\``])
                            .concat(hasBody ? ['bodyRequest'] : [])
                            .concat(
                                [
                                    '{',
                                    ([] as string[])
                                        .concat(hasQueryParam ? [`params: httpParams`] : [])
                                        .concat(hasCustomHeader ? [`headers: headers`] : [])
                                        .join(', '),
                                    '}'
                                ].join(' ')
                            )
                            .join(', ')
                    ],
                    [`)`],
                    [`.pipe(map((x) => ${endpoint.response}.fromRequest(x)));`]
                ].join('')
            ]);

        const feMethodEnd: [string] = [`    }`];

        return ([] as string[]).concat(feMethodStart).concat(feMethodData).concat(feMethodEnd).concat(['']).join('\n');
    });

    return ([] as string[])
        .concat(feImports)
        .concat([''])
        .concat(autoGeneratedMessageHelper())
        .concat([''])
        .concat(feInjectable)
        .concat(classOpening)
        .concat([''])
        .concat(feConstructor)
        .concat([''])
        .concat(feMethods)
        .concat(feClassClosing)
        .join('\n');
}

function generateBeControllerFile(service: Service) {
    const serviceNameCamelCase = toCamelCase(service.name);
    const serviceNameTitleCase = toPascalCase(service.name);
    const serviceImports = serviceImportHelper(service);

    const beImports = [
        `import { Body, Controller, Delete, Get, Param, Patch, Post, Req, UseGuards, Query } from '@nestjs/common';`,
        `import { ApiOperation, ApiTags } from '@nestjs/swagger';`,
        `import { Request } from 'express';`,
        `import { ${serviceImports} } from '${tsConfigPaths['@ericaskari/shared/model']}';`,
        // `import { JwtAuthGuard } from '${tsConfigPaths['@ericaskari/api/core']}';`,
        `import { ${serviceNameTitleCase}Service } from '${tsConfigPaths['@ericaskari/api/core']}';`
    ];

    const beInjectable = [`@ApiTags('${serviceNameTitleCase}')`, `@Controller('${serviceNameCamelCase}')`];

    const beClassOpening = [`export class ${serviceNameTitleCase}Controller {`];
    const beClassClosing = [`}`];

    const beConstructor = [`constructor(private service: ${serviceNameTitleCase}Service) {}`];

    const beMethods = service.endpoints.map((endpoint) => {
        const method = endpoint.type.toLowerCase();
        const hasBody = (method === 'post' || method === 'put') && endpoint.bodyRequest;
        const hasParam = endpoint.urlProps.length > 0 && !!endpoint.bodyRequest && endpoint.url.includes(':');
        const hasQueryParam = !!endpoint.queryParamRequest;

        const props = ([] as string[])
            .concat(hasBody ? [`@Body() bodyRequest: ${endpoint.bodyRequest}`] : [])
            .concat(hasParam ? [`@Param() paramRequest: ${endpoint.paramRequest}`] : [])
            .concat(hasQueryParam ? [`@Query() queryParamRequest: ${endpoint.queryParamRequest}`] : [])
            .concat(endpoint.authenticated ? [`@Req() request: Request`] : [])
            .join(', ');

        const serviceProps = ([] as string[])
            .concat(hasBody ? [`bodyRequest`] : [])
            .concat(hasParam ? [`paramRequest`] : [])
            .concat(hasQueryParam ? [`queryParamRequest`] : [])
            .concat(endpoint.authenticated ? [`request.user as UserModel`] : [])
            .join(', ');

        const methodEnd = [`    }`];

        const methodDecorator = [['    ', `@${toPascalCase(method)}(`, endpoint.url ? `'${endpoint.url}'` : '', ')'].join('')];
        const methodStart = [`    ${endpoint.name}(${props}): Promise<${endpoint.response}> {`];
        const serviceMethod = [`        return this.service.${endpoint.name}(${serviceProps});`];
        return ([] as string[])
            .concat(methodDecorator)
            .concat(endpoint.authenticated ? [`    @UseGuards(JwtAuthGuard)`] : [])
            .concat(methodStart)
            .concat(serviceMethod)
            .concat(methodEnd)
            .join('\n');
    });

    return ([] as string[])
        .concat(beImports)
        .concat([''])
        .concat(autoGeneratedMessageHelper())
        .concat([''])
        .concat(beInjectable)
        .concat(beClassOpening)
        .concat([''])
        .concat(beConstructor)
        .concat([''])
        .concat(beMethods)
        .concat([''])
        .concat(beClassClosing)
        .join('\n');
}

function generateBeInterfaceFile(service: Service) {
    const serviceNameCamelCase = toCamelCase(service.name);
    const serviceNameTitleCase = toPascalCase(service.name);
    const serviceImports = serviceImportHelper(service);

    const imports = [`import { Observable } from 'rxjs';`, `import { ${serviceImports} } from '@ericaskari/shared/model';`];

    const beClassOpening = [`export interface I${serviceNameTitleCase}Service {`];

    const beMethods = service.endpoints.map((endpoint) => {
        const method = endpoint.type.toLowerCase();
        const hasBody = (method === 'post' || method === 'put') && endpoint.bodyRequest;
        const hasParam = endpoint.urlProps.length > 0 && !!endpoint.bodyRequest && endpoint.url.includes(':');
        const hasQueryParam = !!endpoint.queryParamRequest;

        const props = ([] as string[])
            .concat(hasBody ? [`bodyRequest: ${endpoint.bodyRequest}`] : [])
            .concat(hasParam ? [`paramRequest: ${endpoint.paramRequest}`] : [])
            .concat(hasQueryParam ? [`queryParamRequest: ${endpoint.queryParamRequest}`] : [])
            .concat(endpoint.authenticated ? [`userModel: UserModel`] : [])
            .join(', ');

        return `    ${endpoint.name}: (${props}) => Promise<${endpoint.response}>;`;
    });

    const beClassClosing = [`}`];

    return ([] as string[])
        .concat(imports)
        .concat([''])
        .concat(autoGeneratedMessageHelper())
        .concat([''])
        .concat(beClassOpening)
        .concat(beMethods)
        .concat(beClassClosing)
        .join('\n');
}

const services: Service[] = data as Service[];

const imports = services.map((service) => {
    const serviceNameCamelCase = toCamelCase(service.name);
    const serviceNameTitleCase = toPascalCase(service.name);
    const endpointDir = resolve(process.cwd(), `${workspace.projects['web-endpoints']}/src/generated-endpoints`);
    const endpointFile = resolve(endpointDir, `${serviceNameCamelCase}-endpoint.service.ts`);

    const controllerDir = resolve(process.cwd(), `${workspace.projects['api']}/src/app/generated-controllers`);
    const controllerFile = resolve(controllerDir, `${serviceNameCamelCase}.controller.ts`);

    const interfaceDir = resolve(process.cwd(), `${workspace.projects['api-common']}/src/generated-interfaces`);
    const interfaceFile = resolve(interfaceDir, `${serviceNameCamelCase}-service.interface.ts`);

    mkdirSync(endpointDir, { recursive: true });
    mkdirSync(controllerDir, { recursive: true });
    mkdirSync(interfaceDir, { recursive: true });

    writeFileSync(endpointFile, generateFeEndpointFile(service));
    writeFileSync(controllerFile, generateBeControllerFile(service));
    writeFileSync(interfaceFile, generateBeInterfaceFile(service));

    return {
        endpointFile: `export * from './generated-endpoints/${serviceNameCamelCase}-endpoint.service'`,
        controllerFileImports: `import { ${serviceNameTitleCase}Controller } from './generated-controllers/${serviceNameCamelCase}.controller'`,
        controllerFile: `export * from './generated-controllers/${serviceNameCamelCase}.controller'`,
        controllerClassName: `${serviceNameTitleCase}Controller`,
        interfaceFile: `export * from './generated-interfaces/${serviceNameCamelCase}-service.interface'`
    };
});

const generatedEndpoints = resolve(process.cwd(), `${workspace.projects['web-endpoints']}/src/generated-endpoints.ts`);
const generatedControllers = resolve(process.cwd(), `${workspace.projects['api']}/src/app/generated-controllers.ts`);
const generatedInterfaces = resolve(process.cwd(), `${workspace.projects['api-common']}/src/generated-interfaces.ts`);

writeFileSync(
    generatedEndpoints,
    imports.length > 0 ? imports.map((x) => x.endpointFile).join('\n') : 'const endpointPlaceHolder = false;'
);
writeFileSync(
    generatedControllers,
    [
        imports.map((x) => x.controllerFileImports).join('\n'),
        `export const generatedControllers = [${imports.map((x) => x.controllerClassName).join(',')}]`
    ].join('\n')
);
writeFileSync(
    generatedInterfaces,
    imports.length > 0 ? imports.map((x) => x.interfaceFile).join('\n') : 'interface interfacePlaceholder {}'
);
