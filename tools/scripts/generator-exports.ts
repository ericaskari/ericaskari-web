import { mkdirSync, readdirSync, readFileSync, writeFileSync } from 'fs';
import { parse, resolve } from 'path';
import { getClassNameFromFileData, getInterfaceNameFromFileData } from './shared-script';
import workspace from '../../workspace.json';
import baseTsConfig from '../../tsconfig.base.json';

function log(text: string) {
    console.log(' 🛠 ', text);
}

function error(text: string) {
    console.log(' ⛔️ ', text);
}

const autoGeneratedMessage = '// Auto generated file with generate:exports npm command';

function generateDatabaseLibExports(
    input: {
        modelsDir: string;
        entitiesDir: string;
        modelLibImport: string;
        persistenceImport: string;
        enumsImport: string;
    },
    output: { entitiesExportFile: string }
) {
    const modelFileNames = readdirSync(input.modelsDir);

    const entityFileNames = readdirSync(input.entitiesDir);

    const modelsData = modelFileNames.map((m) => readFileSync(resolve(input.modelsDir, m)).toString());

    const entitiesData = entityFileNames.map((m) => readFileSync(resolve(input.entitiesDir, m)).toString());

    const modelsClassNames = modelsData.map((m) => getClassNameFromFileData(m)).filter((x) => !!x);

    const entitiesClassNames = entitiesData.map((m) => getClassNameFromFileData(m)).filter((x) => !!x);

    const indent = '    ';

    const modelImports = `import { \n${indent}${modelsClassNames.join(`,\n${indent}`)} } from '${input.modelLibImport}';`;

    const entityImports = `import { \n${indent}${[...entitiesClassNames, 'entities'].join(`,\n${indent}`)},${indent}\n} from '${
        input.persistenceImport
    }';`;

    const comment = autoGeneratedMessage;

    const typeOrmImport = `import { TypeOrmModule, InjectRepository } from '@nestjs/typeorm';`;

    const repositoryImport = `import { Repository } from 'typeorm';`;
    const entityExposureImport = `import { EntityExposure } from "${input.enumsImport}";`;

    const lastExport = `export const TypeOrmModuleForFeature = TypeOrmModule.forFeature(entities);`;

    const repositoryDefinitionType = `type RepositoryDefinition = () => (target: object, key: string | symbol, index?: number | undefined) => void;`;

    const typeExports = entitiesClassNames.map((className) => `export type { ${className} };`).join('\n');

    const entitiesConverters = entitiesClassNames
        .map((className) =>
            [
                `export const ${className}ModelFromEntity = (model: ${className}): ${className}Model => plainToClass(${className}Model, model);`,
                `export const ${className}ModelToEntity = (model: ${className}Model): ${className} => plainToClass(${className}, model);`,
                `export const ${className}ModelToEntityForUpdate = (model: ${className}Model): ${className} => plainToClass(${className}, model, { groups: [ EntityExposure.toUpdate ]});`,
                `export const ${className}ModelToEntityForSave = (model: ${className}Model): ${className} => plainToClass(${className}, model, { groups: [ EntityExposure.toSave ]});`
            ].join('\n')
        )
        .join('\n');

    const repositoryExports = entitiesClassNames
        .map((className) => `export const Inject${className}Repository: RepositoryDefinition = () => InjectRepository(${className});`)
        .join('\n');

    const repositoryTypeExports = entitiesClassNames
        .map((className) => `export type ${className}Repository = Repository<${className}>;`)
        .join('\n');

    const final = [
        "import { plainToClass } from 'class-transformer';",
        typeOrmImport,
        entityImports,
        modelImports,
        repositoryImport,
        entityExposureImport,
        comment,
        lastExport,
        repositoryDefinitionType,
        typeExports,
        repositoryExports,
        repositoryTypeExports,
        entitiesConverters
    ].join('\n\n');

    writeFileSync(output.entitiesExportFile, final);
}

function generateEntitiesExportFile(input: { entitiesDir: string }, output: { persistenceLibExportsFile: string }) {
    const indent = '    ';

    const entityFileNames = readdirSync(input.entitiesDir);

    const entityFileNamesWithoutExtension = entityFileNames.map((x) => parse(x).name);

    const exportLines = entityFileNamesWithoutExtension.map((x) => `export * from './entities/${x}';`);

    const entitiesData = entityFileNames.map((m) => ({
        fileName: m,
        fileData: readFileSync(resolve(input.entitiesDir, m)).toString()
    }));
    const entitiesClassNames = entitiesData
        .map((m) => ({
            ...m,
            className: getClassNameFromFileData(m.fileData)
        }))
        .filter((x) => !!x);
    const imports =
        entitiesClassNames.length > 0
            ? entitiesClassNames.map((x) => `import { ${x.className} } from './entities/${parse(x.fileName).name}';`).join('\n')
            : '';

    const constants = entitiesClassNames.map((x) => x.className).join(`,\n${indent}`);

    const exportedArray = `export const entities = [\n${indent}${constants}\n];`;

    const exportsString = exportLines.join('\n');

    const final = [imports, autoGeneratedMessage, exportsString, exportedArray].join('\n\n');

    writeFileSync(output.persistenceLibExportsFile, final);
}

function generatePersistenceMigrationsArrayExport(input: { migrationsDir: string }, output: { migrationsFile: string }) {
    const migrationFileNames = readdirSync(input.migrationsDir).filter((x) => x.endsWith('.ts'));
    const startSearchStr = 'export class ';

    const endSearchStr = ' implements MigrationInterface';

    const migrationsData = migrationFileNames.map((m) => readFileSync(resolve(input.migrationsDir, m)).toString());

    const migrationClassNames = migrationsData.map((m) =>
        m.substring(m.lastIndexOf(startSearchStr) + startSearchStr.length, m.lastIndexOf(endSearchStr))
    );

    const imports = migrationClassNames
        .map((migrationClassName: string, index: number) => {
            const fileName = migrationFileNames[index].replace('.ts', '');

            return `import { ${migrationClassName} } from './migrations/${fileName}';`;
        })
        .join('\n');

    const indent = '    ';

    const constants = migrationClassNames.join(`,\n${indent}`);

    const exportedArray = `export const migrations = [\n${indent}${constants}\n];`;

    const comment = autoGeneratedMessage;

    const final = `${imports}\n\n${comment}\n\n${exportedArray}`;

    writeFileSync(output.migrationsFile, final);
}

function generatingModelExports(
    input: {
        readDir: string;
        dirName: string;
        arrayName: string;
    },
    output: { autogeneratedFile: string }
) {
    const fileNames = readdirSync(input.readDir);

    const filesData = fileNames.map((m) => readFileSync(resolve(input.readDir, m)).toString());

    const classNames = filesData.map((m) => getClassNameFromFileData(m));
    const interfaceNames = filesData.map((m) => getInterfaceNameFromFileData(m));

    const classNameImports = classNames
        .map((migrationClassName: string | null, index: number) => {
            const fileName = fileNames[index].replace('.ts', '');
            if (migrationClassName === null) {
                return null;
            }
            return `import { ${migrationClassName} } from './${input.dirName}/${fileName}';`;
        })
        .filter((x) => !!x)
        .join('\n');

    const interfaceImports = interfaceNames
        .map((migrationClassName: string | null, index: number) => {
            const fileName = fileNames[index].replace('.ts', '');
            if (migrationClassName === null) {
                return null;
            }

            return `import { ${migrationClassName} } from './models/${fileName}';`;
        })
        .filter((x) => !!x)
        .join('\n');

    const indent = '    ';

    const classNamesConstants = classNames.filter((x) => !!x).join(`,\n${indent}`);

    const classNameExports = classNames
        .filter((x) => !!x)
        .map((className) => `export { ${className} };`)
        .join('\n');
    const interfaceExports = interfaceNames
        .filter((x) => !!x)
        .map((className) => `export { ${className} };`)
        .join('\n');

    const exportedArray = `export const ${input.arrayName} = [\n${indent}${classNamesConstants}\n];`;

    const comment = autoGeneratedMessage;

    const final = `// noinspection ES6PreferShortImport\n\n${classNameImports}\n\n${interfaceImports}\n\n${comment}\n\n${classNameExports}\n\n${interfaceExports}\n\n${exportedArray}`;

    writeFileSync(output.autogeneratedFile, final);
}

function generateEnumExports(input: { readDir: string }, output: { autogeneratedFile: string }) {
    const fileNames = readdirSync(input.readDir);

    const fileNamesWithoutExtension = fileNames.map((x) => parse(x).name);

    const exportLines = fileNamesWithoutExtension.map((x) => `export * from './enums/${x}';`);

    const exportsString = exportLines.join('\n');

    const comment = autoGeneratedMessage;

    const final = [comment, exportsString].join('\n\n');

    writeFileSync(output.autogeneratedFile, final);
}

function generateExceptionListExport(
    input: { exceptionListFile: string },
    output: {
        exceptionListFactory: string;
        exceptionListFinder: string;
    }
) {
    const file = (() => {
        try {
            return readFileSync(input.exceptionListFile).toString();
        } catch (e) {
            error(`Cannot read ${input.exceptionListFile}`);
            return '';
        }
    })();

    const regex = new RegExp('(?<=export class )(.*)(?= extends HttpException)', 'gi');

    // @ts-ignore
    const classNames = [...file.matchAll(regex)];

    const classNameList = [];
    for (const match of classNames) {
        const fullMatch = match[0];
        classNameList.push(fullMatch);
    }

    const imports = `import {\n    ${classNameList.join(',\n    ')}\n} from './exception.list';`;

    const nameFinders = classNameList.map((className) => `    if (httpException instanceof ${className}) return '${className}';`);

    const factories = classNameList.map(
        (className) =>
            `    if (exceptionName === '${className}') {\n        return new ${className}(formFieldValidationErrors, formValidationErrors);\n    }`
    );

    const factory = `export const ExceptionFactory = (
    exceptionName: string,
    formFieldValidationErrors: { [formFieldName: string]: { [key: string]: boolean } } = {},
    formValidationErrors: { [key: string]: boolean } = {}
) => {
${factories.join('\n')}
    return new HttpException();
};`;

    const nameFinder = `export const ExceptionNameFinder = (httpException: HttpException): string => {
${nameFinders.join('\n')}
    return 'HttpException';
};`;

    writeFileSync(
        output.exceptionListFactory,
        ['import { HttpException } from "./http-exception";', autoGeneratedMessage, imports, factory].join('\n\n')
    );
    writeFileSync(
        output.exceptionListFinder,
        ['import { HttpException } from "./http-exception";', imports, autoGeneratedMessage, nameFinder].join('\n\n')
    );

    //
    // const exportsString = exportLines.join('\n');
    //
    // const comment = autoGeneratedMessage;
    //
    // const final = [comment, exportsString].join('\n\n');
    //
    // writeFileSync(exceptionListFactory, final);
}

{
    const paths = baseTsConfig.compilerOptions.paths;
    const imports: Record<keyof typeof paths, keyof typeof paths> = Object.entries(paths)
        .map(([key]) => key)
        .reduce(
            (json, key) => ({
                ...json,
                [key]: key
            }),
            {} as Record<keyof typeof paths, keyof typeof paths>
        );

    const commonSharedLib = workspace.projects['shared-common'];
    const enumsSharedLib = workspace.projects['shared-enum'];
    const modelsSharedLib = workspace.projects['shared-model'];
    const persistenceApiLib = workspace.projects['api-persistence'];
    const databaseApiLib = workspace.projects['api-database'];
    const enumsImportInput = imports['@ericaskari/shared/enum'];
    const modelLibImportInput = imports['@ericaskari/shared/model'];
    const persistenceImportInput = imports['@ericaskari/api/persistence'];

    const modelsDirInput = resolve(process.cwd(), modelsSharedLib, `src/models`);
    const entitiesDirInput = resolve(process.cwd(), persistenceApiLib, `src/entities`);
    const migrationsDirInput = resolve(process.cwd(), persistenceApiLib, 'src/migrations');
    const requestResponsesDirInput = resolve(process.cwd(), modelsSharedLib, 'src/request-responses');
    const enumsDirInput = resolve(process.cwd(), enumsSharedLib, 'src/enums');

    const exceptionListFileInput = resolve(process.cwd(), commonSharedLib, 'src/exception.list.ts');
    const exceptionListFactoryFileOutput = resolve(process.cwd(), commonSharedLib, 'src/auto-generated-exception.factory.ts');
    const exceptionListFinderFileOutput = resolve(process.cwd(), commonSharedLib, 'src/auto-generated-exception.finder.ts');
    const enumsExportsFileOutput = resolve(process.cwd(), enumsSharedLib, 'src/autogenerated-enums-exports.ts');
    const requestResponsesExportsFileOutput = resolve(process.cwd(), modelsSharedLib, 'src/autogenerated-request-responses-exports.ts');
    const persistenceLibExportsFileOutput = resolve(process.cwd(), persistenceApiLib, 'src/autogenerated-entities-exports.ts');
    const persistenceLibMigrationsArrayExportsFileOutput = resolve(
        process.cwd(),
        persistenceApiLib,
        'src/autogenerated-migrations-exports.ts'
    );
    const databaseLibExportsFileOutput = resolve(process.cwd(), databaseApiLib, `src/autogenerated-exports.ts`);
    const modelsExportFileOutput = resolve(process.cwd(), modelsSharedLib, 'src/autogenerated-model-exports.ts');

    mkdirSync(modelsDirInput, { recursive: true });
    mkdirSync(entitiesDirInput, { recursive: true });
    mkdirSync(migrationsDirInput, { recursive: true });
    mkdirSync(requestResponsesDirInput, { recursive: true });
    mkdirSync(enumsDirInput, { recursive: true });

    log(`Generating exports for ${databaseApiLib} type exports of entities`);
    generateDatabaseLibExports(
        {
            modelsDir: modelsDirInput,
            entitiesDir: entitiesDirInput,
            enumsImport: enumsImportInput,
            modelLibImport: modelLibImportInput,
            persistenceImport: persistenceImportInput
        },
        { entitiesExportFile: databaseLibExportsFileOutput }
    );

    log(`Generating exports for ${persistenceApiLib} entities exports`);
    generateEntitiesExportFile({ entitiesDir: entitiesDirInput }, { persistenceLibExportsFile: persistenceLibExportsFileOutput });

    log(`Generating exports for ${persistenceApiLib} migrations array export`);
    generatePersistenceMigrationsArrayExport(
        { migrationsDir: migrationsDirInput },
        { migrationsFile: persistenceLibMigrationsArrayExportsFileOutput }
    );

    log(`Generating exports for ${modelsSharedLib} models export`);
    generatingModelExports(
        {
            readDir: modelsDirInput,
            dirName: 'models',
            arrayName: 'models'
        },
        {
            autogeneratedFile: modelsExportFileOutput
        }
    );

    log(`Generating exports for ${modelsSharedLib} request-responses export`);
    generatingModelExports(
        {
            readDir: requestResponsesDirInput,
            dirName: 'request-responses',
            arrayName: 'requestResponseModels'
        },
        {
            autogeneratedFile: requestResponsesExportsFileOutput
        }
    );

    log(`Generating exports for ${enumsSharedLib} enums export`);
    generateEnumExports({ readDir: enumsDirInput }, { autogeneratedFile: enumsExportsFileOutput });

    log('Generating auto-generated-exception.factory.ts');
    log('Generating auto-generated-exception.finder.ts');
    generateExceptionListExport(
        { exceptionListFile: exceptionListFileInput },
        {
            exceptionListFinder: exceptionListFinderFileOutput,
            exceptionListFactory: exceptionListFactoryFileOutput
        }
    );

    log('Successfully generated.');
}
